# OAuth 2.0 协议

需要理解的有OAuth 2.0，OIDC，JWT，SSO

常见计算机网络知识参考：https://juejin.cn/post/6844903938232156167#heading-4

# 1. OAuth 2.0 详解

参考文章： https://www.ruanyifeng.com/blog/2019/04/oauth_design.html

首先要理解OAuth是用来做什么。答案也比较清晰，是用来做身份认证的，是一套标准化的流程。

比如说我们登录某一款游戏，首先我们打开游戏，然后点击微信登录。这个时候游戏会拉起微信客户端，同时微信询问我们是否授权，授权之后微信又回拉起游戏客户端。在稍微等待一下之后，我们就发现已经登录成功。

那么这个交互流程中都发生了什么呢？

首先是OAuth2.0 有四种不同的授权流程，我不确定是不是有耐心写完所有的。

## 1.1 授权码模式

这应该是应用最广泛的模式，比如问微信开放平台就是标准的授权码模式。如果感兴趣可以直接百度微信开放平台，上面有整个授权登录的详细过程。授权码模式的核心就是第三方首先获取授权码，然后再去请求token。接下来我们看看授权码模式都是怎么样的流程：

1. 首先A网站提供一个链接，点击之后就跳转到B网站
2. 用户跳转之后需要先登录，登陆之后确认是否授权。统一后会跳转到上一步请求中的重定向url。
3. 跳转时会携带B给A的Access Code，之后A就可以拿着AC去请求token（这一步如果是客户端需要带上ID和密钥来确定身份）
4. 同样通过上一步设置的重定向URL返回用户数据。

这里说的是网站的第三方登录。如果是客户端的第三方登录，需要客户端首先去认证服务器上注册，获取一个独有的ID和密钥，以便身份认证和授权。

**看完这个流程，我觉得最有意思的问题是为什么要先返回一个code而不是直接返回token？**

首先是发起请求的实际上是第三方客户端或者第三方网页，经过跳转来到了授权界面。而token或者code是由授权服务器发送的，是通过请求中的重定向URL来决定发送给谁。在验证过程中，我们已经变成了用户和认证服务器的交互，而不是第三方和认证服务器交互。所以需要跳转回到第三方客户端，这就需要重定向。而HTTP 302 不是安全的，如果直接返回token可能会被劫持。**（是不是有token就不需要其他信息就可以获取用户信息？）**而这里为什么不直接使用https返回是因为不是所有的服务器都支持https，但是当服务器去请求资源服务器或者认证服务器的时候可以保证这些服务器一定是支持https的。



```
针对你说的资源服务器直接请求你的回调url把token带给你，然后服务器存储好token 自己决定如何跳转。
虽然这样做在使用https的情况下确实不会泄漏token了，但是你的第三方应用服务器拿到token，但你怎么知道是哪个用户的token呢？因为资源服务器对你的url直接发起请求是不会带上特定用户正在使用那个浏览器的sessionId的。必须是用户在浏览器对你第三方应用服务器发起请求的行为带上sessionId 你第三方应用服务器才能明确是哪个用户。也就是说Server 对 Server的请求无法带上session，oauth2.0规定返回redirect_uri要用302重定向，302重定向是浏览器行为，sessionid只有在浏览器端维护着，所以auth server只能通过返回一个302响应，让浏览器重新向我们第三方应用发起请求，把code传到我们第三方应用来。第三方应用后端再根据code换取token

作者：没头脑与不开心
链接：https://www.zhihu.com/question/275041157/answer/2950575589
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



# 2. JWT（Json Web Token）

这一节的主要目的就是了解一下JWT存在的目的以及实现原理。同时也整理了一些相关的内容。JWT是用来认证的。

## 2.1 跨域是什么以及为什么要有同源策略

参考文章：https://juejin.cn/post/6844904093417209864

​		一般来说一个URL是由协议 + 域名  + 端口号构成。而当这三个元素中的一个出现不同的时候，我们就称之为跨域。下面就是一些例子。

##### ![截屏2023-06-12 10.43.54](/Users/yuximeng/Library/Application Support/typora-user-images/截屏2023-06-12 10.43.54.png)

策略主要限制js的能力

 	1. 无法读取非同源的 cookie、Storage、indexDB的内容
 	2. 无法读取非同源的DOM
 	3. 无法发送非同源的AJAX，更加准确的说应该是**发送了请求但被浏览器拦截了**。

其实这里就能看出为什么要限制同源，因为如果用户在A网站获取了cookie，然后取浏览B网站。这个时候如果B网站可以读取A网站的cookie，那不是说明B网站可以不通过用户登录A网站，那不是寄了。



## 2.2 JWT就是为了解决跨域认证问题而出现的。

首先互联网服务中，认证是必不可少的。登陆要认证，支付要认证。他们的流程也都大差不多：

1. 首先是用户请求服务，发送用户名验证码

2. 服务器验证之后保存Session的相关数据

3. 服务器再返回一个Session_ID

4. 用户携带Session_ID访问

5. 服务器验证登录

   

但是这样的登录方式有什么问题呢？

首先就是扩展能力不好，因为Session存在本地，持久化在数据库如果数据库挂了就无法正常提供服务了。或者说我访问天猫，登陆之后去访问淘宝，如果单机的话我又要登陆，用户体验很差。

解决办法也是两种，第一种是建立一个持久层，集群中所有的主机都会到这个持久层中来查询Session。

第二种就是JWT这一类，目的是服务器索性不保存了，指通过前端就能够验证登录状态。

### 2.2.1 JWT原理

JWT的原理并不复杂，可以说跟cookie类似。就是用户的每次请求都会携带一个Json格式的token，里面记录了一些用来验证的信息。同时为了防止数据被篡改，JWT也会携带签名来进行认证。

![截屏2023-06-12 11.42.49](/Users/yuximeng/Library/Application Support/typora-user-images/截屏2023-06-12 11.42.49.png)

其中我们可以发现整个JWT是通过两个“.” 分割为三个部分，分别是header，payload和signature。

![截屏2023-06-12 11.45.05](/Users/yuximeng/Library/Application Support/typora-user-images/截屏2023-06-12 11.45.05.png)

接下来就是一次认识一下这个三个部分都是干什么的。

首先是Header：

​				Header部分是一个Json对象，里面存了JWT的元信息，比如加密算法，以及名称。整个header是通过Base64URL转化的字符串，至于Base64URL和Base64的区别就是由于URL中有些字符代表了一些特殊的含义，比如"+", "=" 等等。为了能正确encoding和decoding需要对这些字符做特殊处理。

然后是PayLoad：

​				Payload就是一些数据，他也是Json对象。官方定义了一些字段，当然也支持自定义。需要注意的是PayLoad的encoding和decoding也是Base64URL，也就是说不加密的。所以密码能通过这个进行传输。

![截屏2023-06-12 14.09.07](/Users/yuximeng/Library/Application Support/typora-user-images/截屏2023-06-12 14.09.07.png)

最后是signature：

​				其实听名字就知道是干什么的。就是对前两个部分做的一个签名，防止被篡改了数据。而且我们大致能猜到采用的是非对称加密，客户端通过公钥进行加密，服务器私钥揭秘验证。

### 2.2.2 JWT的使用

JWT可以随着cookie自动发送，但是这样的话会出现跨域问题，可以通过放入HTTP头部的Authorization字段中进行传输。另一种做法是在跨域的时候选择将JWT写入post语句的body中。

### 2.2.3 JWT的特点和一些问题

讨论JWT是否有存在的必要：https://learnku.com/articles/22616

我们先来看看JWT有什么样的特点，再来看JWT适合是什么样子的场景。

其实就是无状态，不需要增加服务器的压力。可以很方便的跨域。

但是致命缺点就是无法控制JWT失效，因为是无状态的。

所以到底JWT是适合什么工作呢？

答案是一次性令牌，或者鉴权。



# 3. 单点登录 （Single Sign On）

单点登录详解参考：https://segmentfault.com/a/1190000022321518

随着互联网服务越来越发的，原先一个系统能处理的请求现在需要进行拆分成不同需求，但是不同系统中用户存在的账户是统一的。这样就导致用户登录不同的系统还需要不停的输入相同的用户名和密码。用户体验较差。

单点用户就是为了解决这种情况而出现的。

总体思路并不复杂，参与者有用户浏览器，系统1，系统2和认证系统。

大体流程为：

用户访问系统一，先去认证系统查看是否有登录记录，发现没有，重定向用户到认证系统，登陆后返回session_ID并且回到系统1，然后重新验证登录，成功后建立局部Session并返回给浏览器。这是用户访问系统二，发现没有局部会话，就去重定向到认证系统，这个时候用户有全局会话，认证系统发现登录过，重定向到系统2并且确认登录，系统2建立局部会话，返回给用户。





